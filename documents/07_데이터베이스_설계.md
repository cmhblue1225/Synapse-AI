# 💾 07. 데이터베이스 설계

## 🗄️ PostgreSQL 15 + pgvector

### 핵심 확장

```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";      -- UUID 생성
CREATE EXTENSION IF NOT EXISTS "pgvector";       -- 벡터 검색
CREATE EXTENSION IF NOT EXISTS "pg_trgm";        -- 텍스트 유사도
```

---

## 📊 주요 테이블 구조

### knowledge_nodes (지식 노드)

```sql
CREATE TABLE knowledge_nodes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    content TEXT,
    node_type TEXT DEFAULT 'Knowledge',         -- Note, WebClip, Document, Concept
    content_type TEXT DEFAULT 'text',
    tags TEXT[] DEFAULT '{}',
    metadata JSONB DEFAULT '{}',                -- 파일 정보, 요약 저장
    embedding VECTOR(1536),                     -- OpenAI 임베딩
    is_public BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### knowledge_relationships (관계)

```sql
CREATE TABLE knowledge_relationships (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_node_id UUID REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    target_node_id UUID REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    relationship_type TEXT DEFAULT 'related_to',
    weight DECIMAL DEFAULT 1.0,
    confidence DECIMAL DEFAULT 0.5,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(source_node_id, target_node_id)  -- 중복 방지
);
```

**관계 유형**:
- `related_to`: 일반적 관련성
- `depends_on`: 의존 관계
- `supports`: 뒷받침
- `contradicts`: 모순
- `similar_to`: 유사
- `part_of`: 포함
- `example_of`: 예시

---

## 🔐 Row Level Security (RLS)

### RLS란?

**Row Level Security**는 SQL 레벨에서 행 단위로 데이터 접근을 제어합니다.

```sql
-- knowledge_nodes RLS
CREATE POLICY "Users can manage own nodes"
ON knowledge_nodes FOR ALL
USING (
  auth.uid() = user_id OR
  (is_public = true AND auth.role() = 'authenticated')
);

-- knowledge_relationships RLS
CREATE POLICY "Users can manage own relationships"
ON knowledge_relationships FOR ALL
USING (
  EXISTS (
    SELECT 1 FROM knowledge_nodes kn
    WHERE (kn.id = source_node_id OR kn.id = target_node_id)
    AND kn.user_id = auth.uid()
  )
);
```

**RLS의 장점**:
- **애플리케이션 코드 독립적**: SQL 레벨 보안
- **자동 적용**: 모든 쿼리에 자동 필터링
- **SQL Injection 방어**: 쿼리 조작 불가

---

## 🚀 인덱스 최적화

### 1. 벡터 검색 인덱스 (IVFFlat)

```sql
CREATE INDEX idx_knowledge_nodes_embedding
ON knowledge_nodes USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);
```

### 2. 일반 인덱스

```sql
-- 사용자별 노드 검색
CREATE INDEX idx_knowledge_nodes_user_id
ON knowledge_nodes(user_id);

-- 태그 검색 (GIN 인덱스)
CREATE INDEX idx_knowledge_nodes_tags
ON knowledge_nodes USING GIN(tags);

-- 최근 노드 정렬
CREATE INDEX idx_knowledge_nodes_created_at
ON knowledge_nodes(created_at DESC);

-- 활성 노드 필터링
CREATE INDEX idx_knowledge_nodes_is_active
ON knowledge_nodes(is_active)
WHERE is_active = true;
```

---

## ⚡ 자동 트리거

### updated_at 자동 업데이트

```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_knowledge_nodes_updated_at
BEFORE UPDATE ON knowledge_nodes
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
```

---

## 💡 면접 포인트

### "RLS로 어떻게 데이터를 보호하나요?"
> "RLS는 **SQL 레벨 보안**으로 `auth.uid() = user_id` 조건이 모든 쿼리에 자동 적용됩니다. 애플리케이션 코드가 아닌 데이터베이스에서 보호하므로 더 안전합니다."

### "IVFFlat 인덱스의 lists = 100은?"
> "데이터를 **100개 클러스터로 분할**하여 검색합니다. 데이터셋 크기가 10만 개 수준이므로 `rows / 1000 = 100`이 최적값입니다."

---

**다음 문서**: [08. 핵심 기능 구현](./08_핵심_기능_구현.md)
**이전 문서**: [06. PDF 처리 파이프라인](./06_PDF_처리_파이프라인.md)
